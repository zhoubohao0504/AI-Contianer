# AI-Contianer
## 设备上线流程
管理员通过后台管理系统配置好货柜、仓门、货道对应关系后，线下去添加设备，设备首次添加会与通信服务建立一个长链接，并且保存设备基本信息到缓存，同时还保存当前货柜与那台通信服务之间建立的链接，更新设备状态为待初始化
非首次添加设备则需要更新设备状态为在线，同时修改缓存中设备基本信息，以及货柜与通信服务的链接关系。

## 设备心跳建立
在设备完成初始化操作以后，设备通过通信服务与设备服务建立一个心跳，该心跳是为了保障设备是处于一个正常的状态。
每30s向设备服务发送一次心跳包，如果距离上次心跳包的时间超过30s就将该设备标记为下线
> question<br>
由于网络抖动导致设备发送的心跳包未能及时到达设备服务，也会把设备标记为下线，但是设备是正常状态的<br>
> resolve<br>
保存最后一次心跳时间到缓存，同时开始定时任务每一分钟去轮询缓存 获取最后一次心跳时间与当前时间做比较 是否超过设置的下线时间阈值<br>
> final resolve<br>
建立心跳表，每次设备发送心跳包以后，心跳计数器+1，更新缓存最后一次收到心跳时间<br>
定时任务查询设备缓存的最后一次心跳时间，如果大于1分钟，去判断当前的设备服务是否是处于一个正常的状态，例如2000台设备1分钟在理想状态下是有4000次心跳发送到设备服务器，针对这个4000次设置一个阈值例如80%就是3200次，那么
在这一分钟下如果心跳包超过3200次，那么说明我的服务是一个正常状态，说明该设备是真的出现故障，将该服务下线

question：<br>
1：建立长链接的目的是什么？<br>
2：定时任务轮询可能会出现 设备量过多 比如2000台设备，轮询到第1000台刚好超过下线时间阈值会导致后续的1000台直接超时<br>
3：心跳检测由设备服务发起？多台设备服务如何区分哪一个心跳检测由某一台服务来完成？就是有没有可能出现重复心跳检测的问题<br>

knowledge points<br>
netty、redis、eureka

## 购买流程
用户扫码以后将当前设备编号与仓门编号通知到APP服务，APP服务区做参数校验、设备校验，以及是否存在未支付订单（基本都是免密支付，存在说明用户一直没钱），生成订单之前先开启一个分布式锁，锁货柜仓门，保障同一时刻只允许一个开门，加锁成功以后会生成我们系统的一个订单号，此时订单状态为预授权状态，仓门状态为未开启，支付状态为未支付<br>
然后向微信或者支付宝去申请授权，更改订单状态为授权中，微信是支付分，支付宝是芝麻信用，这里分为需确认和免去确认（具体选择看实际需求）,同时发送一条延时消息到消息队列，用于判断用户在指定时间内是否授权完成。用户完成授权以后，回调我们的服务告知已经授权成功，更改订单状态为授权成功，发送消息通知设备服务开启仓门，设备服务需要缓存订单信息、货柜信息、仓门信息、货道信息、用户信息等到缓存并且从缓存中获取当前货柜所对应的通信服务是那一台通信服务然后向通信服务发起开门请求，通信服务通知货柜开启仓门，返回设备服务，设备服务标记仓门状态为已开启，同时开启定时任务轮询判断仓门是否已经开启，判断5次以后认定仓门状态为异常，同时取消订单。<br>
当用户关闭仓门以后，需要获取设备的货道重量与开门时保存的重量缓存进行计算得出购买的商品详情及金额，计算完成以后通知账户服务发起扣款请求，并计算是否需要补货，如果需要补货建立补货单，发起补货通知到运营人员

/`
  设备初始化的时候会保存设备信息，仓门信息、货道信息、货道重量到缓存中
  门关着 每90s发送一次重量
  门开着 每300ms发送一次重量
  关门后8s内 每300ms发送一次重量
  发送时有个标记位 表示称是否稳定 0不稳定 1稳定
  重量持续发送 持续保存到数据库
`/

用户关门以后会先获取缓存中开门前记录的各货道的重量，由于用户开门以后设备会每300ms发送一次重量信息到设备服务，设备服务需要保存改重量到数据库和缓存，然后在关门时获取最后一次的重量信息开门前的重量进行计算。<br>
由于发送的重量信息会存在不稳定的数据，不稳定的数据则不会保存，可能会存在缓存里面还是开门前的一个重量，这里记录下最后一次缓存重量的时间，然后在接收到关门指令以后获取系统时间与最后一次重量时间比较，如果最后一次重量时间在关门指令时间前，说明重量不可用<br>
如果一直出现重量不可用，那么等待2s，直到出现可用重量，保障缓存中的重量一定是关门后的重量的。


用户关门时，
*需确认*：每次都需要用户重新确认<br>
*免确认*：授权一次以后都不需要重新授权

knowledge points<br>
分布式锁、消息队列、延时队列



1.难点：对设备的命令的不确定性，由于网络不好，机器不发送开门指令什么
       项目的所有难点都是在设备的一些网络中状态或者是机器的命令的不稳定性
   问题1：服务向机器发送开门指令，机器没有返回值或者长时间未响应。查询一下门的状态，如果没有返回再轮询查几次以后都没有响应 标记订单舱门状态为异常。
   问题2：机器在开门以后 本来订单状态中舱门状态应该是已开门，可能因为网络原因还是其他什么原因 订单状态没有同步，当客户关门时又收到一个关门指令，最开始的时候是判断订单状态是开门中，然后才会去计算重量什么的，这时候由于订单状态是关门，此时的消息就会被丢弃。
         莫名收到一条关门指令的时候，会把改订单标记为异常状态，记录商品详细信息，然后与货柜里面的商品做对比

  问题3：拿一个商品 放入一个同等重量的商品进去
        只能等到补货员补货的时候发现 然后再去排查这个柜子的历史订单，然后根据我们的摄像头记录找到对应人 金额较大报警处理，金额较小通知他付钱，他是在是不付钱，商品标记为正常损耗。

  问题4：从货道4拿一个东西放到货道3中
        先扣钱，订单完成以后如果一个货道的重量增加了，就会产生一条预警信息到运营人员。或者是客户被扣钱以后自己联系客服，提交照片或者根据摄像头观察 是不是真的存在东西放错的情况 再去给他一个退款处理

哪里用到了消息队列
    用户关门以后通过消息队列将订单信息发送给账户服务，告知账户服务接单，如果商品数量小于我们设置的阈值同时也通过消息队列给设备服务发送消息补货通知，然后所有的发送短息通知运营人员都是通过消息队列处理，例如 校准、补过、查验
哪里用到了Redis
    Redis缓存了设备信息，比如Redis的key是我们的设备的一个唯一编号：deviceID,value是对设备序列化后的数据，然后还有最后一次心跳时间，连在哪一个商品服务上。存在一个商品信息，只要是设备相关的会都存在缓存，设备的东西不会经常去修改。
    然后再就是我们的 通信服务 与设备之间的关联关系
  分布式锁：
  下单的时候，同一时刻只允许一个人开门，然后补货、换品改价都是用到这个锁，用的是Redission。
哪里用到了分布式事务：
  强一致性：创建用户的时候，现在APP服务创建用户信息，然后再去账户服务去创建账户信息，必须同时成功才能去买东西，如果用户存在账户不存在那么就会出现无法扣款。用的Seata AT模式，
  最终一致性：设备服务把商品信息算出以后，需要发消息给账户服务、补货服务，这个时候商品已经被拿走了，事务失败不能让用户把商品退回去，发送一个事务性消息给账户服务，账户服务多久结单已经不关设备服务的事了，计算结单失败，重新从RockMq里面重新把消息拿出来再算一遍。      
